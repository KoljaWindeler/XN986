/** * Sonix decoder driver verification example code - normal playback * * @author Evan Chang * @date 01/01/15 * @version 1.0.0 */#include <stdio.h>#include <stdlib.h>#include <string.h>#include <unistd.h>#include <pthread.h>#include <getopt.h>#include <errno.h>#include <fcntl.h>#include <assert.h>#include <math.h>#include <sys/stat.h>#include <sys/types.h>#include <sys/mman.h>#include <sys/time.h>#include <linux/limits.h>#include <linux/videodev2.h>//#include "snx_common.h"#include "sn986_play.h"//#define DEBUG 1#define SUPPORT_VIDEO_OUTPUT 1/******************************************************************************* * Defines ******************************************************************************/#define USE_FRAME_STEP		0#define MAX_BUFFER_COUNT	3#define DEC_DEV_NAME		"/dev/video16"#define VO_DEV_NAME 		"/dev/video3"  #define AVPLAY_VERSION		"v0.1.1"/******************************************************************************* * Structure & enumerate declaration ******************************************************************************//******************************************************************************* * Function declaration ******************************************************************************/static int frame_output(snx_context *ctx);//void *decode_process_thread(void *arg);//void event_loop(snx_context *ctx);/******************************************************************************* * Global variables ******************************************************************************/const char H264marker[] = {0,0,0,1};static const char short_options[] = "hs:B:x:y:o:r";static const struct option long_options[] = {	{"help", no_argument, NULL, 'h'},	{"scale", required_argument, NULL, 's'},	{"output", required_argument, NULL, 'o'},	{"outwidth", required_argument, NULL, 'x'},	{"outheight", required_argument, NULL, 'y'},	{"buffer", required_argument, NULL, 'B'},	{"repeat", no_argument, NULL, 'r'},	{NULL, 0, NULL, 0}};struct snx_avplay_info* avinfo = NULL;char src_file[PATH_MAX] = {0};/******************************************************************************* * Function definition ******************************************************************************/void hexdump(char *buf, size_t len){	char *ptr = (char*) buf;	int i;	for (i = 0; i < len; ++i) {		// 16 bytes align		if (!(i & 0x0F)) printf("\n");		printf("%02X ", ptr[i]);	}	printf("\n\n");}static void usage(FILE *fp, int argc, char **argv){	fprintf(fp, "Usage: %s [options] input\n"			"Version: %s\n"		    "Options:\n"		    "-h Print this message\n"		    "-s, --scale\t\tScaling down ratio 1,2,4, for 1/1, 1/2, 1/4. (default=1)\n"		    "-x, --outwidth\t\tTV/LCD output width (default=src_width/scale)\n"		    "-y, --outheight\t\tTV/LCD output height (default=src_height/scale)\n"		    "-r, --repeat \t\tRepeat Play (default is disable)\n"		    "-B, --buffer\t\tV4L2 buffer. (default=2)\n"		   	"\nEX: %s test.avi -x 640 -y 480\n"		    "", argv[0], AVPLAY_VERSION, argv[0]);}static int frame_output(snx_context *ctx){	struct snx_m2m *m2m = NULL;	int ret;	if (!ctx || !ctx->m2m) {		ret = -1;		goto failed;	}	m2m = ctx->m2m;#if DEBUG		ret = fwrite(m2m->dec_out_buffers[m2m->dec_out_index].start,				1, m2m->dec_out_bytesused, ctx->dst_fp);		if (ret != m2m->dec_out_bytesused) {			int sz_not_writen = m2m->dec_out_bytesused - ret;			printf("error write buffer ret:%d\n", ret);			ret = fwrite(m2m->dec_out_buffers[m2m->dec_out_index].start + ret,					1, sz_not_writen, ctx->dst_fp);			printf("write file final ret:%d\n", ret);		}#endif#if 0   //debug decoded data		ret = fwrite(m2m->dec_cap_buffers[m2m->dec_cap_index].start,				1, m2m->dec_cap_bytesused, ctx->dst_fp);		if (ret != m2m->dec_cap_bytesused) {			int sz_not_writen = m2m->dec_cap_bytesused - ret;			printf("error write buffer ret:%d\n", ret);			ret = fwrite(m2m->dec_cap_buffers[m2m->dec_cap_index].start + ret,					1, sz_not_writen, ctx->dst_fp);			printf("write file final ret:%d\n", ret);		}#endif#if 0	if (ctx->output_mode == MODE_PRINT_SCREEN) {#if _DEBUG_FLOW		printf("capture buffer, bytes: %d\n", m2m->dec_cap_bytesused);#endif		hexdump((char*)m2m->dec_cap_buffers[m2m->dec_cap_index].start, 16/*m2m->dec_cap_bytesused*/);	} else if (ctx->output_mode == MODE_DUMP_FILE) {		ret = fwrite(m2m->dec_cap_buffers[m2m->dec_cap_index].start,				1, m2m->dec_cap_bytesused, ctx->dst_fp);		if (ret != m2m->dec_cap_bytesused) {			int sz_not_writen = m2m->dec_cap_bytesused - ret;			printf("error write buffer ret:%d\n", ret);			ret = fwrite(m2m->dec_cap_buffers[m2m->dec_cap_index].start + ret,					1, sz_not_writen, ctx->dst_fp);			printf("write file final ret:%d\n", ret);		}		//ret = buf.bytesused & 0x0F;		//while (16 - ret) {		//	putc(0, ctx->dst_fp);		//	ret++;		//} // 16 bytes alignment	} else if (ctx->output_mode == MODE_LCD) {		fprintf(stderr, "Not implement output mode: %d\n", ctx->output_mode);	} else {		fprintf(stderr, "Unkown output mode: %d\n", ctx->output_mode);	}#endiffailed:	return ret;}#if 0// extract a frameunsigned char*  extractFrame(unsigned char* frame, size_t& size){				unsigned char * outFrame = NULL;	size_t outsize;	outsize = 0;	outFrame = frame;	while (1) {		char sps_flag = 0;		char pps_flag = 0;		outFrame += outsize;		if ( (size>= sizeof(H264marker)) && (memcmp(outFrame,H264marker,sizeof(H264marker)) == 0) )		{			outsize = sizeof(H264marker);			outFrame += outsize;				switch (outFrame[0]&0x1F)									{					case 7: 						fprintf(stderr, "SPS\n" );						sps_flag = 1;						break;					case 8: 						fprintf(stderr, "PPS\n" );						pps_flag = 1;						break;					default: 						sps_flag = 0;						pps_flag = 0;						size -=  outsize;						break;				}				if (sps_flag || pps_flag) {					for (int i=1; i+sizeof(H264marker) < size; ++i)					{						if (memcmp(&outFrame[i],H264marker,sizeof(H264marker)) == 0)						{							outsize = i; 							sps_flag = 0;							pps_flag = 0;							break;						}						size -=  outsize;					}				} else {					break;				}		} else {			break;		}	}	return outFrame;}#endif// check JFIF in detail//void *decode_process_thread(void *arg)void decode_video_callback( const struct timeval *tv,             void *data,             size_t len,             int keyFrame ){	snx_context *ctx = (snx_context*) avinfo->ctx;	struct snx_m2m *m2m = ctx->m2m;	int ret = 0;	unsigned char* buffer = NULL;	unsigned entropy_coding_mode_flag = 1;	static int first_flag = 1;	if(data == NULL || len == 0) {        fprintf(stderr, "data is null or len is zero\n");        return;    } //   buffer = extractFrame((unsigned char*)data, len);#if VIDEO_PRE_BUFFER    memcpy(m2m->dec_out_buffers[m2m->dec_out_index].start, data,len);#endif    //64 Byte alignment For Sonix h264 Decoder//    printf("old len: %d, ", len);    ret = len % 64;    if (ret)    	len += (64 - ret);//	printf("len: %d\n", len);	// Set to entropy mode 	if(first_flag) {		snx_dec_set_entropy_mode(m2m, entropy_coding_mode_flag);		first_flag == 0;	}	m2m->dec_out_bytesused = len;#if SUPPORT_VIDEO_OUTPUT    if (m2m->vo_mem == V4L2_MEMORY_MMAP)        snx_vo_read (m2m);#endif     	ret = snx_dec_read(m2m);	if (ret < 0) {		perror("decode failed");	}#if SUPPORT_VIDEO_OUTPUT     if (m2m->vo_mem == V4L2_MEMORY_MMAP)          memcpy(m2m->vo_buffers[m2m->vo_index].start, m2m->dec_cap_buffers[m2m->dec_cap_index].start, m2m->dec_cap_bytesused);    else if (m2m->vo_mem == V4L2_MEMORY_USERPTR)    {      snx_vo_reset (m2m);         snx_vo_read (m2m);           }#endif	// output to file, or print on screen	if (m2m->dec_cap_bytesused != 0)		frame_output(ctx);#if SUPPORT_VIDEO_OUTPUT    if (m2m->vo_mem == V4L2_MEMORY_MMAP)              snx_vo_reset (m2m);#endif    		ret = snx_dec_reset(m2m);	if (ret < 0) {		perror("reset failed");	}#if DEBUG		hexdump((char*)m2m->dec_out_buffers[m2m->dec_out_index].start, 16/*m2m->dec_cap_bytesused*/);    	if (m2m->dec_out_bytesused != 0)			frame_output(ctx);#endif}void decode_audio_callback (         const struct timeval *tstamp, void *data, size_t len,         void *cbarg){	int rc;	unsigned int read_frame_size;	unsigned int read_frame, cached_frames = 0;	unsigned int cached_frame_size=0;	int ptr = 0;	int ret;		snx_audio_stream_conf_t *stream = avinfo->audio_pb;	    snd_pcm_hw_params_t *params = stream->params;		read_frame_size = len;		read_frame = read_frame_size * 8 / stream->_format_bits;#if DEBUG			ret =  fwrite(data,1, len, avinfo->audio_pb->dst_fp);        if (ret != len) {			    int sz_not_writen = len - ret;				printf("error write buffer ret:%d\n", ret);				ret = fwrite(data + ret, 1, sz_not_writen, avinfo->audio_pb->dst_fp);				printf("write file final ret:%d\n", ret);		}#endif		//printf(" read_frame = %d, read_frame_size : %d\n", read_frame, read_frame_size);		while ( read_frame ) {			rc = snd_pcm_writei(stream->handle, (char*)data+ptr, (read_frame - cached_frames));						if (rc == -EPIPE) {				snd_pcm_status_t *status;                 snd_pcm_status_alloca(&status);                 if(snd_pcm_status(stream->handle, status) < 0)                     printf("snd_pcm_status fail\n");                 if(snd_pcm_status_get_state(status) == SND_PCM_STATE_XRUN)                     printf("status: SND_PCM_STATE_XRUN\n");                 else                     printf("status: %d\n", snd_pcm_status_get_state(status));                 fprintf(stderr, "Audio playback buffer underrun!\n");                  if(snd_pcm_prepare(stream->handle) < 0)                     printf("snd_pcm_prepare fail\n");				/* EPIPE means overrun */  								continue;			} else if (rc < 0) {  				fprintf(stderr,  "error from read: %s\n", snd_strerror(rc));				continue;			}			ptr += (rc * stream->channel * stream->_format_bits >> 3);			cached_frames = cached_frames + rc;						if (read_frame >= rc ) {				cached_frame_size = cached_frames * stream->channel * stream->_format_bits >> 3;				read_frame = read_frame - rc;			} 						//printf(" rc = %d, cached_frame : %d\n", rc, cached_frame_size);					}}struct snx_avplay_info* createVideoPlay(char* src_file){     struct snx_avplay_info *m_fd = snx986_avplay_new();     if (m_fd) {         strcpy(m_fd->filename, src_file);         snx986_avplay_open(m_fd);     }     return m_fd;}void closeVideoPlay(struct snx_avplay_info* m_fd){	int rc;	if (m_fd) {		if ((rc = snx986_avplay_free(m_fd))) {		fprintf(stderr, "failed to close video source: %s\n", strerror(rc));		}	}}void sighandler(int n){    printf("Signal received (%d)\n", n);    // AVPlay start	snx986_avplay_stop(avinfo);	snx_audio_pb_uninit(avinfo->audio_pb);	snx_dec_stop(avinfo->ctx->m2m);	snx_dec_uninit(avinfo->ctx->m2m);	if (avinfo->audio_pb) free(avinfo->audio_pb);	if (avinfo->ctx->m2m) free(avinfo->ctx->m2m);	if (avinfo->ctx->dst_fp) fclose(avinfo->ctx->dst_fp);	if (avinfo->ctx) free(avinfo->ctx);	if (avinfo) closeVideoPlay(avinfo);	exit(0);}int main(int argc, char **argv){	snx_context *ctx = NULL;	struct snx_m2m *m2m = NULL;	snx_audio_stream_conf_t *audio_pb = NULL;	int output_width = 0, output_height= 0, codec = 0; // 0:h264, 1:mjpeg	int scale_ratio = 1, buf_count = 2;	char dst_file[PATH_MAX] = "test.data";	int ret = -1;	int repeat =  0;	if (argc < 2) {		usage(stderr, argc, argv);		exit(EXIT_FAILURE);	}	while(1) {		int c, index;		c = getopt_long(argc, argv, short_options, long_options, &index);		if (-1 == c) break;		switch(c)		{			case 'h':				usage(stdout, argc, argv);				exit(EXIT_SUCCESS);			case 's':				sscanf(optarg, "%d", &scale_ratio);				if((scale_ratio < 1) && (scale_ratio > 4)) {					printf("Wrong scale ratio: %d, modified to 1\n", scale_ratio);					scale_ratio = 1;				}				if(scale_ratio ==3){					printf("Wrong scale ratio: %d, modified to 1\n", scale_ratio);					scale_ratio = 1;				}				break;			case 'x':				sscanf(optarg, "%d", &output_width);				break;			case 'y':				sscanf(optarg, "%d", &output_height);				break;			case 'r':				repeat = 1;				break;			case 'o':				memset(dst_file, 0, sizeof(dst_file));				strcpy(dst_file, optarg);				break;			case 'B':				sscanf(optarg, "%d", &buf_count);				break;			default:				usage(stderr, argc, argv);				exit(EXIT_FAILURE);		}	}	// Set the source file name	strncpy(src_file, argv[optind], strlen(argv[optind]));	if (strlen(src_file))		avinfo = createVideoPlay(src_file);	else{		printf("NO Source File\n");		exit(EXIT_FAILURE);	}	if (avinfo) {		avinfo->repeat = repeat;		printf("\n\n------- AVPLAY Infomation -------- \n");		printf("width: %d\n", avinfo->width);		printf("height: %d\n", avinfo->height);		printf("fps: %d\n", avinfo->fps);		printf("frame number: %d\n", avinfo->frames_num);		printf("Repeat: %d\n", avinfo->repeat);		printf("\n----------------------------- \n\n");	} else {		printf("AVINFO create failed\n");		exit(EXIT_FAILURE);	}	if(avinfo->video_type == H264_FORMAT)		codec = 0;	else if(avinfo->video_type == MJPEG_FORMAT)		codec = 1;	else {		printf("Wrong Video Type!(%d)\n", avinfo->video_type);		goto failed;	}	/* Check Video Output Widthe / height */	if(output_width){		if(output_width > (avinfo->width/scale_ratio))			output_width = avinfo->width / scale_ratio;	}else		output_width = avinfo->width / scale_ratio;	if(output_height){		if(output_height > (avinfo->height /scale_ratio))			output_height = avinfo->height / scale_ratio;	}else		output_height = avinfo->height / scale_ratio;	/* Start to Setup M2M */	// snx_context allocate and initialize	ctx = (snx_context*) calloc(1, sizeof(snx_context));	if (!ctx) {		printf("create snx_context failed\n");		exit(EXIT_FAILURE);	}	ctx->abort = 0;	ctx->step = USE_FRAME_STEP;	ctx->output_mode = MODE_LCD; 	// snx_m2m allocate and initialize	m2m = (struct snx_m2m*) calloc(1, sizeof(struct snx_m2m));	if (!m2m) {		printf("create snx_m2m failed\n");		goto failed;	}	m2m->m2m = 1;	m2m->width = avinfo->width;	m2m->height = avinfo->height;	m2m->scale = scale_ratio;	m2m->m2m_buffers = fmin(MAX_BUFFER_COUNT, buf_count);	m2m->dec_fmt = codec? V4L2_PIX_FMT_MJPEG: V4L2_PIX_FMT_H264;	//m2m->dec_out_mem = V4L2_MEMORY_MMAP;	//m2m->dec_cap_mem = V4L2_MEMORY_MMAP;	strcpy(m2m->dec_dev, DEC_DEV_NAME);		ctx->m2m = m2m;	avinfo->ctx = ctx;	printf("\n\n------- M2M setting Infomation -------- \n");	printf("m2m: %d outputmode:%d\n",			m2m->m2m, ctx->output_mode);	printf("Setting w:%d h:%d codec:%d scale:%d buf:%d\n",			m2m->width, m2m->height, codec, m2m->scale, m2m->m2m_buffers);	printf("\n----------------------------- \n\n");#if DEBUG	// output file open	if (strlen(dst_file) != 0) {		ctx->dst_fp = fopen(dst_file, "w+b");		if (!ctx->dst_fp) {			ret = -1;			perror("open output file failed");			//printf("open output file '%s' failed\n", dst_file);			goto failed;		}	}#endif	m2m->dec_fd = snx_open_device(m2m->dec_dev);	ret = snx_dec_init(m2m);	if (ret) {		printf("decoder init failed\n");		goto init_failed;	}	ret = snx_dec_start(m2m);	if (ret) {		printf("decoder start failed\n");		goto start_failed;	}	/* Start to Setup Audio */	audio_pb = (snx_audio_stream_conf_t *) malloc(sizeof(snx_audio_stream_conf_t));		avinfo->audio_pb = audio_pb;		if(avinfo->audio_type == ALAW_FORMAT)		audio_pb->format = SND_PCM_FORMAT_A_LAW;	else if(avinfo->audio_type == MULAW_FORMAT)		audio_pb->format = SND_PCM_FORMAT_MU_LAW;	else {		printf("Wrong Audio Type! (%d)\n", avinfo->audio_type);		goto start_failed;	}	audio_pb->open_mode = 0;	audio_pb->channel = 1;	audio_pb->sample_rate = 8000;	ret = audio_pb_format_check(audio_pb);	if (ret < 0) {		printf("[SNX-AUDIO] audio format check error\n");		goto start_failed;	}#if DEBUG	// output file open	if (strlen(dst_file) != 0) {		char audio_dst_file[128];		memset(audio_dst_file, 0, 128);		sprintf(audio_dst_file, "%s.audio", dst_file);		audio_pb->dst_fp = fopen(audio_dst_file, "w+b");		if (!audio_pb->dst_fp) {			ret = -1;			perror("open output file failed");			//printf("open output file '%s' failed\n", dst_file);			goto start_failed;		}	}#endif	snx_audio_pb_init(audio_pb);	// Link CallBack Functions	avinfo->video_cb = decode_video_callback;	avinfo->audio_cb = decode_audio_callback;	// AVPlay start	snx986_avplay_start(avinfo);#if SUPPORT_VIDEO_OUTPUT   strcpy(m2m->vo_dev,VO_DEV_NAME);  m2m->vo_m2m_buffers_count = 2;  //m2m->vo_mem = V4L2_MEMORY_MMAP;  m2m->vo_mem = V4L2_MEMORY_USERPTR;  m2m->vo_data_from = 2;  m2m->in_w = m2m->width / m2m->scale;  m2m->in_h = m2m->height / m2m->scale;  m2m->out_x = 0;  m2m->out_y = 0;  m2m->out_w = output_width;  m2m->out_h = output_height;  m2m->vo_fd = snx_open_device(m2m->vo_dev);  ret = snx_vo_init(m2m);  snx_vo_start(m2m);  if (m2m->vo_mem == V4L2_MEMORY_USERPTR)    printf ("now vo_mem is userprt\n");  else if (m2m->vo_mem == V4L2_MEMORY_MMAP)    printf ("now vo_mem is mmap\n");   else  {    printf ("now vo_mem is no setting\n");    exit (0);      }     #endif	//pthread_create(&ctx->process_tid, NULL, decode_process_thread, (void*)ctx);	// main loop    signal(SIGINT,sighandler);    signal(SIGTERM,sighandler);	while(avinfo->started) {		//Do something here		sleep(2);	}	//pthread_join(ctx->process_tid, NULL);audio_failed:	snx_audio_pb_uninit(audio_pb);start_failed:	snx_dec_stop(m2m);init_failed:	snx_dec_uninit(m2m);rdr_init_failed:	//snx_bs_reader_uninit(m2m);failed:	if (ctx->m2m) free(ctx->m2m);	if (ctx->dst_fp) fclose(ctx->dst_fp);	if (ctx) free(ctx);	if (audio_pb) free(audio_pb);	if (avinfo) closeVideoPlay(avinfo);	return ret;}